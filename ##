package exam;

import java.util.*;
import java.lang.*;
import java.io.*;
//1.각 지역의 인구수는 어떻게 저장해야하는가
//2.주어지는 간선정보는 어떻게 저장해야 하는가?
//1..선거구로 나누는 방법으로 어떤 알고리즘을 사용해야하나? (탐색기법은 맞는데 어떻게?)
//빨간색을 먼저 정하고,
//파란색이 연결이 되는지 확인해야하나?
//모든 경우의수를 확인하고 -> 그게 연결되어있는지 확인하면 됨
//c++의 경우 next_permutation이용하면 되지만 자바는 없기 때문에 dfs->bfs를 이용하도록한다.

class solution2 {
   static int n;// 구역의 개수
   static int[] people;// 사람인구수를 받는다
   static ArrayList<Integer>[] nearby;

   static int min = Integer.MAX_VALUE;

   public static void main(String[] args) throws java.lang.Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      StringTokenizer st;
      st = new StringTokenizer(br.readLine());
      n = Integer.parseInt(st.nextToken());

      // 인구수 저장
      people = new int[n + 1];
      st = new StringTokenizer(br.readLine());
      int sum = 0;
      for (int i = 1; i <= n; i++) {
         people[i] = Integer.parseInt(st.nextToken());
         sum += people[i];
      }

      // 간선 저장
      nearby = (ArrayList<Integer>[]) new ArrayList[n + 1];// 간선저장
      for (int i = 1; i <= n; i++) {
         nearby[i] = new ArrayList<Integer>();
      }

      for (int i = 1; i <= n; i++) {
         st = new StringTokenizer(br.readLine());
         int near = Integer.parseInt(st.nextToken());// 개수
         for (int j = 1; j <= near; j++) {
            int tmp = Integer.parseInt(st.nextToken());
            // System.out.println(tmp);
            nearby[i].add(tmp);
         }
      }
      boolean visited[] = new boolean[n + 1];
      visited[1] = true;
      int tmp_sum = isConnect(visited, n - 1);
      if (tmp_sum != -1) {// 파란색이 연결되어있는지 확인   
         if (Math.abs(sum - 2*tmp_sum) < min) {
            min = Math.abs(sum - 2*tmp_sum);
         }
      }
      
      dfs(1, 0, sum, visited);
      if(min == Integer.MAX_VALUE)
         System.out.println(-1);
      else
         System.out.println(min); // 인구의 차이를 추렭
   }

   public static void dfs(int a, int depth, int sum, boolean[] visited) {// 1. 구역나누기
      if (depth == n - 2) {// 지역-1까지 돌도록
         return;
      }

      // depth는 선택된 빨강이 갯수-1 => 파랑이 = n-(depth+1)
      for (int i = 0; i < nearby[a].size(); i++) {
         if (visited[nearby[a].get(i)] == false) {
            visited[nearby[a].get(i)] = true;
            System.out.println(nearby[a].get(i) + " 방문함");
            int tmp_sum = isConnect(visited, n - depth - 2);
            
            System.out.println("tmp_sum : "+tmp_sum);
            
            if (tmp_sum != -1) {// 파란색이 연결되어있는지 확인   
               //System.out.println("??" + sum);
               System.out.println("hey " +Math.abs(sum - 2*tmp_sum));
               if (Math.abs(sum - 2*tmp_sum) < min) {
                  min = Math.abs(sum - 2*tmp_sum);
               }
            }         
            dfs(nearby[a].get(i), depth + 1, sum, visited);      
            visited[nearby[a].get(i)] = false;
         }
      }
   }

   public static int isConnect(boolean[] visited, int blue) {// 인접해있는지 검사하는 함수
      Queue<Integer> q = new LinkedList<Integer>();
      boolean[] check = new boolean[n+1];
      int ans = 0;
      //System.out.println(blue);
      for(int i=1; i<=n; i++) {
         System.out.print(visited[i] + " ");
      }
      System.out.println();
      for (int i = 1; i <= n; i++) {
         if (visited[i] == false) {//System.out.println("@@"+i);
            check[i] = true;
            q.add(i);
            break;
         }
      }

      while (!q.isEmpty()) {
         int p = q.poll();
         ans += people[p];
      //   System.out.println("사람 " + ans);
         blue--;
         System.out.print(p + " ");
         for (int i = 0; i < nearby[p].size(); i++) {
            if (visited[nearby[p].get(i)] == false && check[nearby[p].get(i)] == false) {
               check[nearby[p].get(i)] = true;
               //System.out.println(p + ", " + nearby[p].get(i));
               q.add(nearby[p].get(i));
            }
         }
      }
      System.out.println(blue+"파랑이 남은애======");
      //System.out.println(blue);
      if (blue != 0)
         return -1;
      //System.out.println("?dddd " + ans);
      return ans;
   }
}
